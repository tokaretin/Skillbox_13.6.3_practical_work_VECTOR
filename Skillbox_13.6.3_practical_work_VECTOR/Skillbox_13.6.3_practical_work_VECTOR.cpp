/*Задача 3
Что нужно сделать
Вам дали задание разработать хранилище для целочисленных значений во встраиваемой операционной системе.
Такие системы работают в большей части техники, которая нас окружает: автомобилях, стиральных машинах, 
микроволновках, холодильниках. Только вот незадача: объём памяти этой системы очень небольшой, поэтому
в хранилище не может находиться более 20 элементов.

В хранилище, являющееся вектором, с клавиатуры приходят целочисленные значения и помещаются 
один за другим.

При вводе «−1» с клавиатуры необходимо вывести всё содержимое хранилища (20 или менее элементов). 
При выводе элементы должны быть в том порядке, в котором они добавлялись.

Попробуйте написать максимально оптимизированное решение этой задачи, чтобы совершалось как 
можно меньше расширений и перемещений элементов внутри вектора.

Чтобы задать размера вектора равным 20, используйте:
std::vector<int> db(20);

// Задаём размер вектора при создании

Пример выполнения:
input number: 1
input number: 2
input number: 3
…
input number: 19
input number: 20
input number: -1
output: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
input number: 21
input number: 22
input number: 23
input number: -1
output: 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23

Рекомендации по выполнению
Посмотрите, как работает кольцевой буфер. Этот алгоритм поможет быстрее найти решение.
*/
#include <iostream>
#include <vector>

int main() {
    std::vector<int> maxSize(5); // Создаем вектор с фиксированным размером 20
    int start = 0; // Позиция начала maxSize
    int end = 0; // Позиция конца maxSize
    int count = 0; // Количество элементов в maxSize

    int input;
    while (true) {
        std::cout << "Input number: ";
        std::cin >> input;

        if (input == -1) {
            // Выводим все элементы из maxSize.size() в порядке добавления
            for (int i = 0; i < count; i++) {
                std::cout << maxSize[(start + i) % maxSize.size()] << " ";
            }
            std::cout << std::endl;
            continue;
        }

        maxSize[end] = input; // Добавляем значение в конец maxSize
        end = (end + 1) % maxSize.size(); // Обновляем позицию конца maxSize

        if (count < maxSize.size()) {
            count++; // Увеличиваем количество элементов в maxSize
        }
        else {
            start = (start + 1) % maxSize.size(); // maxSize заполнен, перемещаем позицию начала
        }
    }

    return 0;
}








          
          
 

